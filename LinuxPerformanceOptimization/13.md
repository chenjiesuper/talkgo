## 使用 stress 命令，无法模拟 iowait 高的场景
使用 stress 无法模拟 iowait 升高，但是却看到了 sys 升高。这是因为案例中 的 stress -i 参数，它表示通过系统调用 sync() 来模拟 I/O 的问题，但这种方法实际上并不可靠。因为 sync() 的本意是刷新内存缓冲区的数据到磁盘中，以确保同步。如果缓冲区内本来就没多少数据，那读写到磁盘中的数据也就不多，也就没法产生 I/O 压力。
这一点，在使用 SSD 磁盘的环境中尤为明显，很可能你的 iowait 总是 0，却单纯因为大量的系统调用，导致了系统 CPU 使用率 sys 升高。
你可以运行下面的命令，来模拟 iowait 的问题。
```
# -i的含义还是调用sync，而—hdd则表示读写临时文件
$ stress-ng -i 1 --hdd 1 --timeout 600
```
## 无法模拟出 RES 中断的问题
* pidstat 中， %wait 表示进程等待 CPU 的时间百分比。
* top 中 ，iowait% 则表示等待 I/O 的 CPU 时间百分比。
* 回忆一下我们学过的进程状态，你应该记得，等待 CPU 的进程已经在 CPU 的就绪队列中，处于运行状态；而等待 I/O 的进程则处于不可中断状态。
Ubuntu 18.04 中，运行 sysbench 的格式为：
```
$ sysbench --threads=10 --max-time=300 threads run
```
而在 Ubuntu 16.04 中，运行格式则为（感谢 Haku 留言分享的执行命令）：
```
$ sysbench --num-threads=10 --max-time=300 --test=threads run
```

## 专栏金句
>学习是一个“从薄到厚再变薄”的过程，我们从细节知识入手开始学习，积累到一定程度，需要整理成一个体系来记忆，这其中还要不断地对这个体系进行细节修补。有疑问、有反思才可以达到最佳的学习效果。
