## CPU 的上下文切换不同的场景
* 进程上下文切换
* 线程上下文切换
* 中断上下文切换

## 进程上下文切换
### 特权等级
* 内核空间（Ring 0）具有最高权限，可以直接访问所有资源
* 用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。


### vs系统调用
从用户态到内核态的转变，需要通过系统调用来完成。**一次系统调用的过程，其实是发生了两次 CPU 上下文切换。**
进程上下文切换，是指从一个进程切换到另一个进程运行。**而系统调用过程中一直是同一个进程在运行。**
系统调用过程通常称为特权模式切换，而不是上下文切换。但实际上，系统调用过程中，**CPU 的上下文切换还是无法避免的。**
进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要**先**把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。


### 对性能的影响
每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。

## 线程上下文切换
### vs进程
线程是调度的基本单位，而进程则是资源拥有的基本单位。
* 当进程只有一个线程时，可以认为进程就等于线程。
* 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。
* 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。


### 场景
* 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。
* 前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。


### 对性能的影响
比多进程间的切换消耗更少的资源，而这，也正是多线程代替多进程的一个优势。

## 中断上下文切换
中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。
跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。
对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。
### 对性能的影响
跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能。

## 发现专栏精选留言
>进程切换我想到了很多年前在银行柜台办理业务的情形。
>1：银行分配各个窗口给来办理业务的人
>2：如果只有1个窗口开放（系统资源不足），大部分都得等
>3：如果正在办理业务的突然说自己不办了（sleep）,那他就去旁边再想想（等）
>4：如果突然来了个VIP客户，可以强行插队
>5：如果突然断电了（中断），都得等。。

思考：形象生动，加深理解。
